# 题目描述：
一盗墓贼，进入古墓，发现众多独一无二的奇珍异宝设为n（ 1<n<10000）件，第i件物品的重量为w[i],价值为v[i],但盗墓贼使出浑身力气也只能搬走总重量为k的物品（假设至少有一个珍宝的重量小于k），盗墓贼该如何取舍，才能搬走总价值最大的珍宝，其中w[i],v[i]均为int类型，按编号从大到小打印挑选方案。

# 输入数据有多行
第一行：盗墓贼能搬走的总重量，如样例能搬走的总重量为5，即k=5
第二行：珍宝数量，如样例珍宝的数量为3，即n=3
第三行：每件珍宝的重量，如样例编号为1的重量为3，编号2的重量为2，编号3的总量为2，即w[1]=3,w[2]=2,w[3]=2
第四行：每件珍宝的价值，如样例编号为1的价值为30，编号2的价值为10，编号3的价值为10，即v[1]=30,v[2]=10,v[3]=10

# 输出
按编号从大到小输出挑选方案，编号从1开始，若遇重量相等，价值相等的珍宝，优先挑选编号小的珍宝，如样例挑选出编号为1，2的满足总重量小于5且价值最大，按从大到小输出编号为2  1

# 样例输入
5
3
3 2 2
30 10 10

# 样例输出
2 1

# 思路：动态规划
1. 如果当前物品超重，不拿。v[i][j] = v[i-1][j-1]
2. 如果当前物品没有超重，比较不拿得到的价值多，还是拿了之后，本物品的价值+（j-weight[i-1]）能拿的物品价值多

```python
k = 4#weight
n = 3#amount
weight = [3,2,2]
value = [30,10,10]

v = [[0]*(k+1)] * (n+1)
for i in range(1, n+1): #数量 
    for j in range(1, k+1): # 重量
        if weight[i-1] > j:
            v[i][j] = v[i-1][j-1]
        else:
            v[i][j] = max(v[i-1][j-1], v[i-1][j-weight[i-1]]+value[i-1])

print(max(v[:][-1]))
```